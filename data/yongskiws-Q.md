### [LOW-1] require() should be used instead of assert()
``` solidity
File: cash\factory\CashFactory.sol
97:     assert(cashProxyAdmin.owner() == guardian);

File: cash\factory\CashKYCSenderFactory.sol
106:     assert(cashKYCSenderProxyAdmin.owner() == guardian);

File: cash\factory\CashKYCSenderReceiverFactory.sol
106:     assert(cashKYCSenderReceiverProxyAdmin.owner() == guardian);

File: lending\compound\Comptroller.sol
266:     assert(assetIndex < len);
443:     assert(markets[cToken].accountMembership[borrower]);
```

### [LOW-2] Lack of zero address check 
``` solidity
File: cash\CashManager.sol
128:     address _collateral,
129:     address _cash,
132:     address _assetRecipient,
133:     address _assetSender,
134:     address _feeRecipient,
138:     address _kycRegistry,
```

### [LOW-3] function onlyOwner doesn't have strict validation consider use multisig
``` solidity 

File: lending\OndoPriceOracle.sol
80:   function setPrice(address fToken, uint256 price) external override onlyOwner {
81:     uint256 oldPrice = fTokenToUnderlyingPrice[fToken];
82:     fTokenToUnderlyingPrice[fToken] = price;
83:     emit UnderlyingPriceSet(fToken, oldPrice, price);
84:   }

File: lending\OndoPriceOracle.sol
92:   function setFTokenToCToken(
93:     address fToken,
94:     address cToken
95:   ) external override onlyOwner {
96:     address oldCToken = fTokenToCToken[fToken];
97:     _setFTokenToCToken(fToken, cToken);
98:     emit FTokenToCTokenSet(fToken, oldCToken, cToken);
99:   }

File: lending\OndoPriceOracle.sol
106:   function setOracle(address newOracle) external override onlyOwner {
107:     address oldOracle = address(cTokenOracle);
108:     cTokenOracle = CTokenOracle(newOracle);
109:     emit CTokenOracleSet(oldOracle, newOracle);
110:   }
111: 

File: lending\OndoPriceOracleV2.sol
130:   function setPriceCap(
131:     address fToken,
132:     uint256 value
133:   ) external override onlyOwner {
134:     uint256 oldPriceCap = fTokenToUnderlyingPriceCap[fToken];
135:     fTokenToUnderlyingPriceCap[fToken] = value;
136:     emit PriceCapSet(fToken, oldPriceCap, value);
137:   }
138: 


File: lending\OndoPriceOracleV2.sol
145:   function setFTokenToOracleType(
146:     address fToken,
147:     OracleType oracleType
148:   ) external override onlyOwner {
149:     fTokenToOracleType[fToken] = oracleType;
150:     emit FTokenToOracleTypeSet(fToken, oracleType);
151:   }


File: lending\OndoPriceOracleV2.sol
163:   function setPrice(address fToken, uint256 price) external override onlyOwner {
164:     require(
165:       fTokenToOracleType[fToken] == OracleType.MANUAL,
166:       "OracleType must be Manual"
167:     );
168:     uint256 oldPrice = fTokenToUnderlyingPrice[fToken];
169:     fTokenToUnderlyingPrice[fToken] = price;
170:     emit UnderlyingPriceSet(fToken, oldPrice, price);
171:   }


File: lending\OndoPriceOracleV2.sol
182:   function setOracle(address newOracle) external override onlyOwner {
183:     address oldOracle = address(cTokenOracle);
184:     cTokenOracle = CTokenOracle(newOracle);
185:     emit CTokenOracleSet(oldOracle, newOracle);
186:   }
187: 

File: lending\OndoPriceOracleV2.sol
194:   function setFTokenToCToken(
195:     address fToken,
196:     address cToken
197:   ) external override onlyOwner {
198:     address oldCToken = fTokenToCToken[fToken];
199:     _setFTokenToCToken(fToken, cToken);
200:     emit FTokenToCTokenSet(fToken, oldCToken, cToken);
201:   }

File:  lending\OndoPriceOracleV2.sol
233:   function setFTokenToChainlinkOracle(
234:     address fToken,
235:     address newChainlinkOracle
236:   ) external override onlyOwner {
237:     address oldChainlinkOracle = address(
238:       fTokenToChainlinkOracle[fToken].oracle
239:     );
240:     _setFTokenToChainlinkOracle(fToken, newChainlinkOracle);
241:     emit ChainlinkOracleSet(fToken, oldChainlinkOracle, newChainlinkOracle);
242:   }


File:  lending\OndoPriceOracleV2.sol
309:   function setMaxChainlinkOracleTimeDelay(
310:     uint256 _maxChainlinkOracleTimeDelay
311:   ) external override onlyOwner {
312:     uint256 oldMaxDelay = maxChainlinkOracleTimeDelay;
313:     maxChainlinkOracleTimeDelay = _maxChainlinkOracleTimeDelay;
314:     emit MaxChainlinkOracleTimeDelaySet(
315:       oldMaxDelay,
316:       _maxChainlinkOracleTimeDelay
317:     );
318:   }

```

### [LOW-4] Add constructor initializers
Note that this behaviour is also incorporated the OZ Wizard since the UUPS vulnerability discovery: “Additionally, we modified the code generated by the Wizard 19 to include a constructor that automatically initializes the implementation when deployed.”
Furthermore, this thwarts any attempts to frontrun the initialization tx of these contracts:

``` solidity
File:  cash\token\CashKYCSender.sol
46:   function initialize(
47:     string memory name,
48:     string memory symbol,
49:     address kycRegistry,
50:     uint256 kycRequirementGroup
51:   ) public initializer {
52:     __ERC20PresetMinterPauser_init(name, symbol);
53:     __KYCRegistryClientInitializable_init(kycRegistry, kycRequirementGroup);
54:   }


File: cash\token\CashKYCSenderReceiver.sol
46:   function initialize(
47:     string memory name,
48:     string memory symbol,
49:     address kycRegistry,
50:     uint256 kycRequirementGroup
51:   ) public initializer {
52:     __ERC20PresetMinterPauser_init(name, symbol);
53:     __KYCRegistryClientInitializable_init(kycRegistry, kycRequirementGroup);
54:   }
55: 


File: lending\tokens\cCash\CCash.sol
30:   function initialize(
31:     address underlying_,
32:     ComptrollerInterface comptroller_,
33:     InterestRateModel interestRateModel_,
34:     uint initialExchangeRateMantissa_,
35:     string memory name_,
36:     string memory symbol_,
37:     uint8 decimals_,
38:     address kycRegistry_,
39:     uint kycRequirementGroup_
40:   ) public {
41:     // CToken initialize does the bulk of the work
42:     super.initialize(
43:       comptroller_,
44:       interestRateModel_,
45:       initialExchangeRateMantissa_,
46:       name_,
47:       symbol_,
48:       decimals_,
49:       kycRegistry_,
50:       kycRequirementGroup_
51:     );
52: 
53:     // Set underlying and sanity check it
54:     underlying = underlying_;
55:     EIP20Interface(underlying).totalSupply();
56:   }
```

